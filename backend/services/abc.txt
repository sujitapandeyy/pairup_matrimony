from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
from Crypto.Random import get_random_bytes
import base64

AES_KEY = b'ThisIsA16ByteKey'  # Store securely, use env in prod

def encrypt_message(message: str) -> str:
    cipher = AES.new(AES_KEY, AES.MODE_CBC)
    ct_bytes = cipher.encrypt(pad(message.encode('utf-8'), AES.block_size))
    iv = base64.b64encode(cipher.iv).decode('utf-8')
    ct = base64.b64encode(ct_bytes).decode('utf-8')
    return f"{iv}:{ct}"

def decrypt_message(cipher_text: str) -> str:
    try:
        iv, ct = cipher_text.split(":")
        iv = base64.b64decode(iv)
        ct = base64.b64decode(ct)
        cipher = AES.new(AES_KEY, AES.MODE_CBC, iv)
        pt = unpad(cipher.decrypt(ct), AES.block_size)
        return pt.decode('utf-8')
    except Exception:
        return "[Decryption Failed]"












from flask import current_app, jsonify
from datetime import datetime

from flask import current_app, jsonify
from datetime import datetime
from utils.encryption import decrypt_message

class ChatService:

    def serialize_message(self, msg):
        ts = msg.get('timestamp')
        if isinstance(ts, datetime):
            ts_iso = ts.isoformat()
        else:
            try:
                ts_iso = datetime.fromisoformat(ts).isoformat()
            except Exception:
                ts_iso = datetime.utcnow().isoformat()

        return {
            'sender': msg.get('sender', ''),
            'receiver': msg.get('receiver', ''),
            'message': decrypt_message(msg.get('message', '')),
            'timestamp': ts_iso,
        }

    def get_chat_history(self, user1, user2):
        if not user1 or not user2:
            return jsonify({'error': 'Missing user1 or user2 parameter'}), 400

        mongo = current_app.mongo
        messages_cursor = mongo.db.chat_messages.find({
            '$or': [
                {'sender': user1, 'receiver': user2},
                {'sender': user2, 'receiver': user1}
            ]
        }).sort('timestamp', 1)

        messages = [self.serialize_message(m) for m in messages_cursor]
        return jsonify({'messages': messages})


    def update_read_receipt(self, data):
        user = data.get('user')
        chat_with = data.get('chat_with')
        timestamp = data.get('timestamp')

        if not user or not chat_with or not timestamp:
            return jsonify({"error": "Missing fields"}), 400

        mongo = current_app.mongo
        mongo.db.read_receipts.update_one(
            {"user": user, "chat_with": chat_with},
            {"$set": {"last_read": timestamp}},
            upsert=True
        )
        return jsonify({"message": "Read receipt updated"})

    def get_read_receipt(self, user, chat_with):
        if not user or not chat_with:
            return jsonify({"error": "Missing fields"}), 400

        mongo = current_app.mongo
        doc = mongo.db.read_receipts.find_one({
            "user": user,
            "chat_with": chat_with
        })

        return jsonify({"last_read": doc.get("last_read") if doc else None})







from flask_socketio import SocketIO, join_room, emit
from flask import current_app, request
from datetime import datetime
from bson import ObjectId
from utils.encryption import encrypt_message  # üîê Add this

socketio = SocketIO(cors_allowed_origins="*", async_mode='eventlet')

online_users = set()

def get_room_id(user1, user2):
    if not user1 or not user2:
        return None
    return '_'.join(sorted([user1, user2]))

def serialize_objectid(obj):
    if isinstance(obj, list):
        return [serialize_objectid(o) for o in obj]
    if isinstance(obj, dict):
        return {k: serialize_objectid(v) for k, v in obj.items()}
    if isinstance(obj, ObjectId):
        return str(obj)
    return obj

def register_socketio_events(app):
    @socketio.on('connect')
    def handle_connect():
        user_email = request.args.get('email')
        if user_email:
            online_users.add(user_email)
            print(f"‚úÖ {user_email} connected")
            emit('online_users', list(online_users), broadcast=True)

    @socketio.on('disconnect')
    def handle_disconnect():
        user_email = request.args.get('email')
        if user_email:
            online_users.discard(user_email)
            print(f"‚ùå {user_email} disconnected")
            emit('online_users', list(online_users), broadcast=True)

    @socketio.on('join_room')
    def on_join(data):
        user1 = data.get('user1')
        user2 = data.get('user2')
        room = get_room_id(user1, user2)
        if room:
            print(f"üì• {user1} joined room with {user2}")
            join_room(room)
        else:
            print("‚ùó Invalid join_room data:", data)

    @socketio.on('send_message')
    def handle_send_message(data):
        required_keys = ['sender', 'receiver', 'message']
        if not all(k in data for k in required_keys):
            print("‚ùó Invalid message data received:", data)
            return

        room = get_room_id(data['sender'], data['receiver'])

        # üîê Encrypt the message before storing
        encrypted_msg = encrypt_message(data['message'])

        chat = {
            "sender": data['sender'],
            "receiver": data['receiver'],
            "message": encrypted_msg,  # Store encrypted
            "timestamp": datetime.utcnow()
        }

        try:
            db = current_app.mongo.db
            result = db.chat_messages.insert_one(chat)
            chat['_id'] = str(result.inserted_id)
        except Exception as e:
            print("‚ùå Error saving message to DB:", str(e))

        # Emit decrypted message in real-time
        emit('receive_message', {
            "sender": chat["sender"],
            "receiver": chat["receiver"],
            "message": data["message"],  # Plaintext for frontend
            "timestamp": chat["timestamp"].isoformat(),
            "_id": chat.get('_id'),
        }, room=room)



``````````````````raw chatservices`````````````````````
from flask import current_app, jsonify
from datetime import datetime

class ChatService:

    def serialize_message(self, msg):
        ts = msg.get('timestamp')
        if isinstance(ts, datetime):
            ts_iso = ts.isoformat()
        else:
            try:
                ts_iso = datetime.fromisoformat(ts).isoformat()
            except Exception:
                ts_iso = datetime.utcnow().isoformat()

        return {
            'sender': msg.get('sender', ''),
            'receiver': msg.get('receiver', ''),
            'message': msg.get('message', ''),
            'timestamp': ts_iso,
        }

    def get_chat_history(self, user1, user2):
        if not user1 or not user2:
            return jsonify({'error': 'Missing user1 or user2 parameter'}), 400

        mongo = current_app.mongo
        messages_cursor = mongo.db.chat_messages.find({
            '$or': [
                {'sender': user1, 'receiver': user2},
                {'sender': user2, 'receiver': user1}
            ]
        }).sort('timestamp', 1)

        messages = [self.serialize_message(m) for m in messages_cursor]

        return jsonify({'messages': messages})

    def update_read_receipt(self, data):
        user = data.get('user')
        chat_with = data.get('chat_with')
        timestamp = data.get('timestamp')

        if not user or not chat_with or not timestamp:
            return jsonify({"error": "Missing fields"}), 400

        mongo = current_app.mongo
        mongo.db.read_receipts.update_one(
            {"user": user, "chat_with": chat_with},
            {"$set": {"last_read": timestamp}},
            upsert=True
        )
        return jsonify({"message": "Read receipt updated"})

    def get_read_receipt(self, user, chat_with):
        if not user or not chat_with:
            return jsonify({"error": "Missing fields"}), 400

        mongo = current_app.mongo
        doc = mongo.db.read_receipts.find_one({
            "user": user,
            "chat_with": chat_with
        })

        return jsonify({"last_read": doc.get("last_read") if doc else None})



``````````````````raw sockent event````````````````
from flask_socketio import SocketIO, join_room, emit
from flask import current_app, request
from datetime import datetime
from bson import ObjectId

socketio = SocketIO(cors_allowed_origins="*", async_mode='eventlet')

online_users = set()

def get_room_id(user1, user2):
    if not user1 or not user2:
        return None
    return '_'.join(sorted([user1, user2]))

def serialize_objectid(obj):
    if isinstance(obj, list):
        return [serialize_objectid(o) for o in obj]
    if isinstance(obj, dict):
        return {k: serialize_objectid(v) for k, v in obj.items()}
    if isinstance(obj, ObjectId):
        return str(obj)
    return obj

def register_socketio_events(app):
    @socketio.on('connect')
    def handle_connect():
        user_email = request.args.get('email')
        if user_email:
            online_users.add(user_email)
            print(f" {user_email} connected")
            emit('online_users', list(online_users), broadcast=True)

    @socketio.on('disconnect')
    def handle_disconnect():
        user_email = request.args.get('email')
        if user_email:
            online_users.discard(user_email)
            print(f" {user_email} disconnected")
            emit('online_users', list(online_users), broadcast=True)

    @socketio.on('join_room')
    def on_join(data):
        user1 = data.get('user1')
        user2 = data.get('user2')
        room = get_room_id(user1, user2)
        if room:
            print(f" {user1} joined room with {user2}")
            join_room(room)
        else:
            print(" Invalid join_room data:", data)

    @socketio.on('send_message')
    def handle_send_message(data):
        required_keys = ['sender', 'receiver', 'message']
        if not all(k in data for k in required_keys):
            print(" Invalid message data received:", data)
            return

        room = get_room_id(data['sender'], data['receiver'])
        chat = {
            "sender": data['sender'],
            "receiver": data['receiver'],
            "message": data['message'],
            "timestamp": datetime.utcnow()
        }

        try:
            db = current_app.mongo.db
            result = db.chat_messages.insert_one(chat)
            chat['_id'] = str(result.inserted_id)  
        except Exception as e:
            print(" Error saving message to DB:", str(e))

        emit('receive_message', {
            **chat,
            "timestamp": chat["timestamp"].isoformat(),
            "_id": chat.get('_id'),
        }, room=room)
