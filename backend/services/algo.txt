from math import radians, sin, cos, sqrt, atan2

class MatchAlgorithm:
    def __init__(self, db):
        self.users = db["users"]
        self.details = db["user_details"]
        self.interests = db["user_interests"]
        self.swipes = db["swipes"]

    def _cosine_similarity(self, vec1, vec2):
        """Calculate cosine similarity between two vectors from scratch"""
        dot_product = sum(a*b for a,b in zip(vec1, vec2))
        magnitude1 = sqrt(sum(a**2 for a in vec1))
        magnitude2 = sqrt(sum(b**2 for b in vec2))
        
        if magnitude1 == 0 or magnitude2 == 0:
            return 0
        return dot_product / (magnitude1 * magnitude2)

    def _text_to_vector(self, text):
        """Convert text to word frequency vector"""
        words = text.lower().split()
        word_counts = {}
        for word in words:
            word_counts[word] = word_counts.get(word, 0) + 1
        return word_counts

    def _vectorize_features(self, user_data, candidate_data):
        """Create feature vectors for similarity calculation"""
        # Combine all text features into one string
        user_text = " ".join([
            str(user_data.get("religion", "")),
            str(user_data.get("education", "")),
            str(user_data.get("profession", "")),
            " ".join(user_data.get("hobbies", [])),
            " ".join(user_data.get("personality", []))
        ])
        
        candidate_text = " ".join([
            str(candidate_data.get("religion", "")),
            str(candidate_data.get("education", "")),
            str(candidate_data.get("profession", "")),
            " ".join(candidate_data.get("hobbies", [])),
            " ".join(candidate_data.get("personality", []))
        ])
        
        # Get word frequencies
        user_vec = self._text_to_vector(user_text)
        candidate_vec = self._text_to_vector(candidate_text)
        
        # Get all unique words
        all_words = set(user_vec.keys()).union(set(candidate_vec.keys()))
        
        # Create numerical vectors
        vec1 = [user_vec.get(word, 0) for word in all_words]
        vec2 = [candidate_vec.get(word, 0) for word in all_words]
        
        return vec1, vec2

    def _apply_rule_based_filtering(self, user_prefs, candidate_data):
        """Apply strict rules for gender and caste"""
        # Gender filtering
        preferred_genders = [g.strip().lower() 
                           for g in user_prefs.get("gender", "any").split(",")]
        candidate_gender = str(candidate_data.get("gender", "")).lower()
        
        if "any" not in preferred_genders and candidate_gender not in preferred_genders:
            return False

        # Caste filtering
        user_caste_pref = user_prefs.get("caste", "any").lower()
        candidate_caste = str(candidate_data.get("caste", "")).lower()
        
        if user_caste_pref != "any" and candidate_caste != "any":
            if user_caste_pref != candidate_caste:
                return False

        return True

    def _calculate_compatibility(self, user_detail, user_interests, candidate_detail, distance_km):
        """Calculate compatibility score from scratch"""
        # Rule-based filtering first
        user_prefs = user_interests.get("looking_for", {})
        if not self._apply_rule_based_filtering(user_prefs, candidate_detail):
            return 0

        # Content-based similarity
        vec1, vec2 = self._vectorize_features(user_detail, candidate_detail)
        content_score = self._cosine_similarity(vec1, vec2) * 70  # 70% weight
        
        # Location score (10% weight)
        location_score = 0
        if distance_km <= 50:
            location_score = 10
        elif distance_km <= 1000:
            location_score = 10 * (1 - (distance_km - 50) / 950)
            
        # Age score (10% weight)
        age_score = 0
        try:
            user_age = user_detail.get("age")
            candidate_age = candidate_detail.get("age")
            age_pref = user_prefs.get("age_group", "18-99")
            min_age, max_age = map(int, age_pref.split("-"))
            
            if min_age <= candidate_age <= max_age:
                age_score = 10
        except:
            pass
            
        # Mutual interests score (10% weight)
        interest_score = 0
        user_hobbies = set(str(h).lower() for h in user_detail.get("hobbies", []))
        candidate_hobbies = set(str(h).lower() for h in candidate_detail.get("hobbies", []))
        if user_hobbies and candidate_hobbies:
            common = user_hobbies & candidate_hobbies
            interest_score = 10 * len(common) / len(user_hobbies)
            
        total_score = content_score + location_score + age_score + interest_score
        return min(100, max(0, total_score))  # Ensure 0-100 range

    def _get_document(self, collection, user_id):
        """Helper to get document by user_id"""
        return collection.find_one({"user_id": user_id}) or collection.find_one({"user_id": str(user_id)})

    def _get_interests_list(self, interests_doc, details_doc):
        """Get combined interests list from documents"""
        interests = []
        def extend_clean(data):
            if isinstance(data, list):
                interests.extend([i.strip() for i in data if i])
            elif isinstance(data, str):
                interests.append(data.strip())

        if interests_doc:
            extend_clean(interests_doc.get("interests"))
            extend_clean(interests_doc.get("hobbies"))
            extend_clean(interests_doc.get("personality"))

            looking_for = interests_doc.get("looking_for", {})
            if isinstance(looking_for, dict):
                extend_clean(looking_for.get("interests"))
                extend_clean(looking_for.get("hobbies"))
                extend_clean(looking_for.get("personality"))

        if details_doc:
            extend_clean(details_doc.get("interests"))
            extend_clean(details_doc.get("hobbies"))
            extend_clean(details_doc.get("personality"))

        return list(set(filter(None, interests)))

    def _haversine(self, lat1, lon1, lat2, lon2):
        """Calculate distance between two points on Earth (in km)"""
        R = 6371.0
        dlat = radians(lat2 - lat1)
        dlon = radians(lon2 - lon1)
        a = sin(dlat / 2) ** 2 + cos(radians(lat1)) * cos(radians(lat2)) * sin(dlon / 2) ** 2
        c = 2 * atan2(sqrt(a), sqrt(1 - a))
        return R * c

    def _get_location(self, user_detail):
        """Extract location coordinates from user detail"""
        if not user_detail:
            return None
        if "location_coordinates" in user_detail:
            coords = user_detail["location_coordinates"]
            if isinstance(coords, dict):
                try:
                    lat = float(coords.get("lat", 0))
                    lng = float(coords.get("lng", 0))
                    if lat != 0 and lng != 0:
                        return {"lat": lat, "lng": lng}
                except (ValueError, TypeError):
                    pass
        try:
            lat = user_detail.get("latitude")
            lng = user_detail.get("longitude")
            if lat is not None and lng is not None:
                return {
                    "lat": float(lat),
                    "lng": float(lng)
                }
        except (ValueError, TypeError):
            pass
        return None

    def _build_photo_url(self, request, raw_photo):
        """Build full photo URL from request"""
        base_url = request.host_url.rstrip('/')
        if raw_photo:
            if raw_photo.startswith("/uploads/"):
                return f"{base_url}{raw_photo}"
            return raw_photo
        return f"{base_url}/default-profile.jpg"

    def _process_candidate(self, request, candidate, partner_gender_pref, liked_emails, liked_by_emails, user_detail, user_interests_list, user_location):
        """Process a candidate profile for matching"""
        email = candidate.get("email")
        if email in liked_emails or email in liked_by_emails:
            return None

        detail = self._get_document(self.details, candidate["_id"])
        if not detail:
            return None

        candidate_interests = self._get_document(self.interests, candidate["_id"])
        candidate_location = self._get_location(detail)

        distance = None
        if user_location and candidate_location:
            distance = self._haversine(
                user_location["lat"], user_location["lng"],
                candidate_location["lat"], candidate_location["lng"]
            )

        compatibility_score = self._calculate_compatibility(
            user_detail,
            self._get_document(self.interests, user_detail.get("user_id") or user_detail.get("_id")),
            detail,
            distance or 0
        )

        return {
            "id": str(candidate["_id"]),
            "name": candidate.get("name"),
            "email": email,
            "age": detail.get("age"),
            "gender": detail.get("gender"),
            "religion": detail.get("religion"),
            "caste": detail.get("caste"),
            "marital_status": detail.get("marital_status"),
            "location": detail.get("location"),
            "profession": detail.get("profession"),
            "education": detail.get("education"),
            "bio": detail.get("caption", "No bio available."),
            "personality": detail.get("personality", []),
            "hobbies": detail.get("hobbies", []),
            "images": [self._build_photo_url(request, candidate.get("photo"))],
            "is_match": email in liked_by_emails,
            "distance_km": round(distance, 2) if distance is not None else None,
            "compatibility_score": compatibility_score
        }

    def get_profiles(self, request, current_email):
        """Get potential matches for current user"""
        user = self.users.find_one({"email": current_email})
        if not user:
            return {"profiles": []}

        user_detail = self._get_document(self.details, user["_id"])
        if not user_detail:
            return {"profiles": []}

        user_interests = self._get_document(self.interests, user["_id"])
        user_location = self._get_location(user_detail)
        liked_emails, liked_by_emails = self._get_swipe_data(current_email)
        partner_gender_pref = self._get_gender_preference(user_interests or {})

        profiles = []
        for candidate in self.users.find({"email": {"$ne": current_email}}):
            profile = self._process_candidate(
                request, candidate, partner_gender_pref,
                liked_emails, liked_by_emails,
                user_detail, user_interests, user_location
            )
            if profile:
                profiles.append(profile)

        # Sort by compatibility score descending
        profiles.sort(key=lambda x: -x["compatibility_score"])

        return {
            "profiles": profiles,
            "logged_in_user": self._build_user_profile(request, user, user_detail, user_interests)
        }

    def _get_gender_preference(self, user_interests):
        """Extract gender preference from user interests"""
        if not user_interests:
            return "any"
        if "looking_for" in user_interests and isinstance(user_interests["looking_for"], dict):
            if "gender" in user_interests["looking_for"]:
                pref = user_interests["looking_for"]["gender"]
                if pref:
                    return str(pref).strip().lower()
        if "gender_preference" in user_interests:
            pref = user_interests["gender_preference"]
            if pref:
                return str(pref).strip().lower()
        return "any"

    def _get_swipe_data(self, current_email):
        """Get swipes involving current user"""
        swiped_by_user = {s["target"] for s in self.swipes.find({"swiper": current_email})}
        swiped_on_user = {s["swiper"] for s in self.swipes.find({"target": current_email})}
        return swiped_by_user, swiped_on_user

    def _build_user_profile(self, request, user, user_detail, interests):
        """Build profile object for response"""
        looking_for = {}
        if user_detail:
            raw_interests = self._get_document(self.interests, user["_id"])
            if raw_interests and isinstance(raw_interests.get("looking_for"), dict):
                looking_for = raw_interests["looking_for"]

        return {
            "name": user.get("name"),
            "email": user.get("email"),
            "gender": user_detail.get("gender") if user_detail else None,
            "age": user_detail.get("age") if user_detail else None,
            "location": user_detail.get("location") if user_detail else None,
            "religion": user_detail.get("religion") if user_detail else None,
            "caste": user_detail.get("caste") if user_detail else None,
            "marital_status": user_detail.get("marital_status") if user_detail else None,
            "education": user_detail.get("education") if user_detail else None,
            "profession": user_detail.get("profession") if user_detail else None,
            "bio": user_detail.get("caption", "No bio available.") if user_detail else None,
            "personality": user_detail.get("personality", []) if user_detail else [],
            "hobbies": user_detail.get("hobbies", []) if user_detail else [],
            "looking_for": looking_for,
            "images": [self._build_photo_url(request, user.get("photo"))] if user.get("photo") else [self._build_photo_url(request, None)]
        }







        ``````````````impressed````````````````````
        from math import radians, sin, cos, sqrt, atan2

class MatchAlgorithm:
    def __init__(self, db):
        self.users = db["users"]
        self.details = db["user_details"]
        self.interests = db["user_interests"]
        self.swipes = db["swipes"]

    def _cosine_similarity(self, vec1, vec2):
        """Calculate cosine similarity between two vectors from scratch"""
        dot_product = sum(a*b for a,b in zip(vec1, vec2))
        magnitude1 = sqrt(sum(a**2 for a in vec1))
        magnitude2 = sqrt(sum(b**2 for b in vec2))
        
        if magnitude1 == 0 or magnitude2 == 0:
            return 0
        return dot_product / (magnitude1 * magnitude2)

    def _text_to_vector(self, text):
        """Convert text to word frequency vector"""
        words = text.lower().split()
        word_counts = {}
        for word in words:
            word_counts[word] = word_counts.get(word, 0) + 1
        return word_counts

    def _vectorize_features(self, user_data, candidate_data):
        """Create feature vectors for similarity calculation with feature tracking"""
        # Combine all text features into one string
        features = {
            'religion': str(user_data.get("religion", "")),
            'education': str(user_data.get("education", "")),
            'profession': str(user_data.get("profession", "")),
            'hobbies': " ".join(user_data.get("hobbies", [])),
            'personality': " ".join(user_data.get("personality", []))
        }
        
        user_text = " ".join(features.values())
        candidate_text = " ".join([
            str(candidate_data.get("religion", "")),
            str(candidate_data.get("education", "")),
            str(candidate_data.get("profession", "")),
            " ".join(candidate_data.get("hobbies", [])),
            " ".join(candidate_data.get("personality", []))
        ])
        
        # Get word frequencies
        user_vec = self._text_to_vector(user_text)
        candidate_vec = self._text_to_vector(candidate_text)
        
        # Get all unique words
        all_words = set(user_vec.keys()).union(set(candidate_vec.keys()))
        
        # Create numerical vectors
        vec1 = [user_vec.get(word, 0) for word in all_words]
        vec2 = [candidate_vec.get(word, 0) for word in all_words]
        
        return vec1, vec2, features

    def _parse_preferences(self, preference_value):
        """Parse preference string/list into a set of normalized values"""
        if not preference_value:
            return set()
        
        if isinstance(preference_value, list):
            return {str(item).strip().lower() for item in preference_value}
        
        if isinstance(preference_value, str):
            if ',' in preference_value:
                return {item.strip().lower() for item in preference_value.split(',')}
            return {preference_value.strip().lower()}
        
        return set()

    def _apply_rule_based_filtering(self, user_prefs, candidate_data):
        """Apply strict rules for gender and caste with multiple preferences"""
        # Gender filtering
        preferred_genders = self._parse_preferences(user_prefs.get("gender", "any"))
        candidate_gender = str(candidate_data.get("gender", "")).lower()
        
        if "any" not in preferred_genders and candidate_gender not in preferred_genders:
            return False, "Gender preference mismatch"

        # Caste filtering - handle multiple preferred castes
        user_caste_prefs = self._parse_preferences(user_prefs.get("caste", "any"))
        candidate_caste = str(candidate_data.get("caste", "")).lower()
        
        if "any" not in user_caste_prefs and candidate_caste:
            if candidate_caste not in user_caste_prefs:
                return False, f"Caste not in preferred: {user_caste_prefs}"

        return True, "Passed all filters"

    def _calculate_compatibility(self, user_detail, user_interests, candidate_detail, distance_km):
        """Calculate compatibility score with detailed breakdown"""
        score_breakdown = {
            'total_score': 0,
            'content_similarity': {'score': 0, 'matched_features': []},
            'location': {'score': 0, 'distance_km': distance_km},
            'age': {'score': 0, 'user_age': user_detail.get("age"), 'candidate_age': candidate_detail.get("age")},
            'interests': {'score': 0, 'common_hobbies': [], 'user_hobbies': [], 'candidate_hobbies': []},
            'filter_passed': True,
            'rejection_reason': None
        }

        # Rule-based filtering first
        user_prefs = user_interests.get("looking_for", {})
        passed, reason = self._apply_rule_based_filtering(user_prefs, candidate_detail)
        if not passed:
            score_breakdown['filter_passed'] = False
            score_breakdown['rejection_reason'] = reason
            return score_breakdown

        # Content-based similarity (70% weight)
        vec1, vec2, features = self._vectorize_features(user_detail, candidate_detail)
        content_score = self._cosine_similarity(vec1, vec2) * 70
        score_breakdown['content_similarity']['score'] = content_score
        score_breakdown['content_similarity']['matched_features'] = [
            f"{k}: {v}" for k,v in features.items() if v
        ]

        # Location score (10% weight)
        location_score = 0
        if distance_km <= 50:
            location_score = 10
        elif distance_km <= 1000:
            location_score = 10 * (1 - (distance_km - 50) / 950)
        score_breakdown['location']['score'] = location_score

        # Age score (10% weight)
        age_score = 0
        try:
            user_age = user_detail.get("age")
            candidate_age = candidate_detail.get("age")
            age_pref = user_prefs.get("age_group", "18-99")
            
            if '-' in age_pref:
                min_age, max_age = map(int, age_pref.split('-'))
            else:
                min_age, max_age = 18, 99
                
            if min_age <= candidate_age <= max_age:
                age_score = 10
                score_breakdown['age']['match'] = f"Within preferred range ({min_age}-{max_age})"
            else:
                score_breakdown['age']['match'] = f"Outside preferred range ({min_age}-{max_age})"
        except Exception as e:
            score_breakdown['age']['error'] = str(e)
        score_breakdown['age']['score'] = age_score

        # Mutual interests score (10% weight)
        interest_score = 0
        user_hobbies = set(str(h).lower() for h in user_detail.get("hobbies", []))
        candidate_hobbies = set(str(h).lower() for h in candidate_detail.get("hobbies", []))
        
        score_breakdown['interests']['user_hobbies'] = list(user_hobbies)
        score_breakdown['interests']['candidate_hobbies'] = list(candidate_hobbies)
        
        if user_hobbies and candidate_hobbies:
            common = user_hobbies & candidate_hobbies
            interest_score = 10 * len(common) / len(user_hobbies)
            score_breakdown['interests']['common_hobbies'] = list(common)
            score_breakdown['interests']['match_percentage'] = f"{len(common)/len(user_hobbies)*100:.1f}%"
        
        score_breakdown['interests']['score'] = interest_score
            
        total_score = content_score + location_score + age_score + interest_score
        score_breakdown['total_score'] = min(100, max(0, total_score))
        
        return score_breakdown

    def _get_document(self, collection, user_id):
        """Helper to get document by user_id"""
        return collection.find_one({"user_id": user_id}) or collection.find_one({"user_id": str(user_id)})

    def _get_interests_list(self, interests_doc, details_doc):
        """Get combined interests list from documents"""
        interests = []
        def extend_clean(data):
            if isinstance(data, list):
                interests.extend([i.strip() for i in data if i])
            elif isinstance(data, str):
                interests.append(data.strip())

        if interests_doc:
            extend_clean(interests_doc.get("interests"))
            extend_clean(interests_doc.get("hobbies"))
            extend_clean(interests_doc.get("personality"))

            looking_for = interests_doc.get("looking_for", {})
            if isinstance(looking_for, dict):
                extend_clean(looking_for.get("interests"))
                extend_clean(looking_for.get("hobbies"))
                extend_clean(looking_for.get("personality"))

        if details_doc:
            extend_clean(details_doc.get("interests"))
            extend_clean(details_doc.get("hobbies"))
            extend_clean(details_doc.get("personality"))

        return list(set(filter(None, interests)))

    def _haversine(self, lat1, lon1, lat2, lon2):
        """Calculate distance between two points on Earth (in km)"""
        R = 6371.0
        dlat = radians(lat2 - lat1)
        dlon = radians(lon2 - lon1)
        a = sin(dlat / 2) ** 2 + cos(radians(lat1)) * cos(radians(lat2)) * sin(dlon / 2) ** 2
        c = 2 * atan2(sqrt(a), sqrt(1 - a))
        return R * c

    def _get_location(self, user_detail):
        """Extract location coordinates from user detail"""
        if not user_detail:
            return None
        if "location_coordinates" in user_detail:
            coords = user_detail["location_coordinates"]
            if isinstance(coords, dict):
                try:
                    lat = float(coords.get("lat", 0))
                    lng = float(coords.get("lng", 0))
                    if lat != 0 and lng != 0:
                        return {"lat": lat, "lng": lng}
                except (ValueError, TypeError):
                    pass
        try:
            lat = user_detail.get("latitude")
            lng = user_detail.get("longitude")
            if lat is not None and lng is not None:
                return {
                    "lat": float(lat),
                    "lng": float(lng)
                }
        except (ValueError, TypeError):
            pass
        return None

    def _build_photo_url(self, request, raw_photo):
        """Build full photo URL from request"""
        base_url = request.host_url.rstrip('/')
        if raw_photo:
            if raw_photo.startswith("/uploads/"):
                return f"{base_url}{raw_photo}"
            return raw_photo
        return f"{base_url}/default-profile.jpg"

    def _process_candidate(self, request, candidate, partner_gender_pref, liked_emails, liked_by_emails, user_detail, user_interests_list, user_location):
        """Enhanced to include score breakdown"""
        email = candidate.get("email")
        if email in liked_emails or email in liked_by_emails:
            return None

        detail = self._get_document(self.details, candidate["_id"])
        if not detail:
            return None

        candidate_interests = self._get_document(self.interests, candidate["_id"])
        candidate_location = self._get_location(detail)

        distance = None
        if user_location and candidate_location:
            distance = self._haversine(
                user_location["lat"], user_location["lng"],
                candidate_location["lat"], candidate_location["lng"]
            )

        compatibility = self._calculate_compatibility(
            user_detail,
            self._get_document(self.interests, user_detail.get("user_id") or user_detail.get("_id")),
            detail,
            distance or 0
        )

        if not compatibility['filter_passed']:
            return None

        return {
            "id": str(candidate["_id"]),
            "name": candidate.get("name"),
            "email": email,
            "age": detail.get("age"),
            "gender": detail.get("gender"),
            "religion": detail.get("religion"),
            "caste": detail.get("caste"),
            "marital_status": detail.get("marital_status"),
            "location": detail.get("location"),
            "profession": detail.get("profession"),
            "education": detail.get("education"),
            "bio": detail.get("caption", "No bio available."),
            "personality": detail.get("personality", []),
            "hobbies": detail.get("hobbies", []),
            "images": [self._build_photo_url(request, candidate.get("photo"))],
            "is_match": email in liked_by_emails,
            "distance_km": round(distance, 2) if distance is not None else None,
            "compatibility_score": compatibility['total_score'],
            "score_breakdown": {  # Detailed matching reasons
                'content_similarity': {
                    'score': f"{compatibility['content_similarity']['score']:.1f}/70",
                    'matched_features': compatibility['content_similarity']['matched_features']
                },
                'location': {
                    'score': f"{compatibility['location']['score']:.1f}/10",
                    'distance': f"{distance:.1f} km" if distance else "Unknown"
                },
                'age': {
                    'score': f"{compatibility['age']['score']:.1f}/10",
                    'details': compatibility['age'].get('match', 'Not specified')
                },
                'interests': {
                    'score': f"{compatibility['interests']['score']:.1f}/10",
                    'common_hobbies': compatibility['interests']['common_hobbies'],
                    'match_percentage': compatibility['interests'].get('match_percentage', '0%')
                }
            }
        }

    def get_profiles(self, request, current_email):
        """Get potential matches for current user"""
        user = self.users.find_one({"email": current_email})
        if not user:
            return {"profiles": []}

        user_detail = self._get_document(self.details, user["_id"])
        if not user_detail:
            return {"profiles": []}

        user_interests = self._get_document(self.interests, user["_id"])
        user_location = self._get_location(user_detail)
        liked_emails, liked_by_emails = self._get_swipe_data(current_email)
        partner_gender_pref = self._get_gender_preference(user_interests or {})

        profiles = []
        for candidate in self.users.find({"email": {"$ne": current_email}}):
            profile = self._process_candidate(
                request, candidate, partner_gender_pref,
                liked_emails, liked_by_emails,
                user_detail, user_interests, user_location
            )
            if profile:
                profiles.append(profile)

        # Sort by compatibility score descending
        profiles.sort(key=lambda x: -x["compatibility_score"])

        return {
            "profiles": profiles,
            "logged_in_user": self._build_user_profile(request, user, user_detail, user_interests)
        }

    def _get_gender_preference(self, user_interests):
        """Extract gender preference from user interests"""
        if not user_interests:
            return "any"
        
        # Handle both old and new preference formats
        if "looking_for" in user_interests and isinstance(user_interests["looking_for"], dict):
            if "gender" in user_interests["looking_for"]:
                pref = user_interests["looking_for"]["gender"]
                if pref:
                    return str(pref).strip().lower()
        
        if "gender_preference" in user_interests:
            pref = user_interests["gender_preference"]
            if pref:
                return str(pref).strip().lower()
        
        return "any"

    def _get_swipe_data(self, current_email):
        """Get swipes involving current user"""
        swiped_by_user = {s["target"] for s in self.swipes.find({"swiper": current_email})}
        swiped_on_user = {s["swiper"] for s in self.swipes.find({"target": current_email})}
        return swiped_by_user, swiped_on_user

    def _build_user_profile(self, request, user, user_detail, interests):
        """Build profile object for response"""
        looking_for = {}
        if user_detail:
            raw_interests = self._get_document(self.interests, user["_id"])
            if raw_interests and isinstance(raw_interests.get("looking_for"), dict):
                looking_for = raw_interests["looking_for"]

        return {
            "name": user.get("name"),
            "email": user.get("email"),
            "gender": user_detail.get("gender") if user_detail else None,
            "age": user_detail.get("age") if user_detail else None,
            "location": user_detail.get("location") if user_detail else None,
            "religion": user_detail.get("religion") if user_detail else None,
            "caste": user_detail.get("caste") if user_detail else None,
            "marital_status": user_detail.get("marital_status") if user_detail else None,
            "education": user_detail.get("education") if user_detail else None,
            "profession": user_detail.get("profession") if user_detail else None,
            "bio": user_detail.get("caption", "No bio available.") if user_detail else None,
            "personality": user_detail.get("personality", []) if user_detail else [],
            "hobbies": user_detail.get("hobbies", []) if user_detail else [],
            "looking_for": looking_for,
            "images": [self._build_photo_url(request, user.get("photo"))] if user.get("photo") else [self._build_photo_url(request, None)]
        }





        `````````````````````final``````````````````````````````````````````
        from math import radians, sin, cos, sqrt, atan2

class MatchAlgorithm:
    def __init__(self, db):
        self.users = db["users"]
        self.details = db["user_details"]
        self.interests = db["user_interests"]
        self.swipes = db["swipes"]

    def _cosine_similarity(self, vec1, vec2):
        """Calculate cosine similarity between two vectors from scratch"""
        dot_product = sum(a*b for a,b in zip(vec1, vec2))
        magnitude1 = sqrt(sum(a**2 for a in vec1))
        magnitude2 = sqrt(sum(b**2 for b in vec2))
        
        if magnitude1 == 0 or magnitude2 == 0:
            return 0
        return dot_product / (magnitude1 * magnitude2)

    def _text_to_vector(self, text):
        """Convert text to word frequency vector"""
        words = text.lower().split()
        word_counts = {}
        for word in words:
            word_counts[word] = word_counts.get(word, 0) + 1
        return word_counts

    def _parse_preferences(self, preference_value):
        """Parse preference string/list into a set of normalized values"""
        if not preference_value:
            return set()
        
        if isinstance(preference_value, list):
            return {str(item).strip().lower() for item in preference_value}
        
        if isinstance(preference_value, str):
            if ',' in preference_value:
                return {item.strip().lower() for item in preference_value.split(',')}
            return {preference_value.strip().lower()}
        
        return set()

    def _apply_rule_based_filtering(self, user_prefs, candidate_data):
        """Apply strict rules for gender and caste with multiple preferences"""
        # Gender filtering
        preferred_genders = self._parse_preferences(user_prefs.get("gender", "any"))
        candidate_gender = str(candidate_data.get("gender", "")).lower()
        
        if "any" not in preferred_genders and candidate_gender not in preferred_genders:
            return False, "Gender preference mismatch"

        # Caste filtering - handle multiple preferred castes
        user_caste_prefs = self._parse_preferences(user_prefs.get("caste", "any"))
        candidate_caste = str(candidate_data.get("caste", "")).lower()
        
        if "any" not in user_caste_prefs and candidate_caste:
            if candidate_caste not in user_caste_prefs:
                return False, f"Caste not in preferred: {user_caste_prefs}"

        return True, "Passed all filters"

    def _calculate_compatibility(self, user_detail, user_interests, candidate_detail, distance_km):
        """Calculate comprehensive compatibility score with all factors"""
        score_breakdown = {
            'total_score': 0,
            'factors': {
                'age': {'score': 0, 'weight': 10, 'details': ''},
                'religion': {'score': 0, 'weight': 10, 'details': ''},
                'education': {'score': 0, 'weight': 10, 'details': ''},
                'profession': {'score': 0, 'weight': 5, 'details': ''},
                'hobbies': {'score': 0, 'weight': 10, 'details': ''},
                'marital_status': {'score': 0, 'weight': 10, 'details': ''},
                'distance': {'score': 0, 'weight': 10, 'details': ''},
                'personality': {'score': 0, 'weight': 10, 'details': ''},
                'living_preference': {'score': 0, 'weight': 10, 'details': ''},
                'family_type': {'score': 0, 'weight': 10, 'details': ''},
                'family_values': {'score': 0, 'weight': 10, 'details': ''},
                'pet_preference': {'score': 0, 'weight': 5, 'details': ''}
            },
            'filter_passed': True,
            'rejection_reason': None
        }

        # Rule-based filtering first
        user_prefs = user_interests.get("looking_for", {})
        passed, reason = self._apply_rule_based_filtering(user_prefs, candidate_detail)
        if not passed:
            score_breakdown['filter_passed'] = False
            score_breakdown['rejection_reason'] = reason
            return score_breakdown

        # Age Compatibility (10 points)
        try:
            user_age = user_detail.get("age")
            candidate_age = candidate_detail.get("age")
            age_pref = user_prefs.get("age_group", "18-99")
            
            # Check user's age preference against candidate's age
            if isinstance(age_pref, str) and '-' in age_pref:
                min_age, max_age = map(int, age_pref.split('-'))
            else:
                min_age, max_age = 18, 99
                
            if min_age <= candidate_age <= max_age:
                age_score = 5
                score_breakdown['factors']['age']['details'] = f"Within your preferred range ({min_age}-{max_age})"
            else:
                age_score = 0
                score_breakdown['factors']['age']['details'] = f"Outside your preferred range ({min_age}-{max_age})"

            # Check candidate's age preference against user's age
            candidate_interests = self._get_document(self.interests, candidate_detail.get("user_id") or candidate_detail.get("_id"))
            if candidate_interests and isinstance(candidate_interests.get("looking_for"), dict):
                cand_age_pref = candidate_interests["looking_for"].get("age_group")
                if cand_age_pref:
                    try:
                        c_min, c_max = map(int, cand_age_pref.split('-'))
                        if c_min <= user_age <= c_max:
                            age_score += 5
                            score_breakdown['factors']['age']['details'] += " | You're within their preferred range"
                        else:
                            score_breakdown['factors']['age']['details'] += " | You're outside their preferred range"
                    except ValueError:
                        pass
            
            score_breakdown['factors']['age']['score'] = age_score
        except Exception as e:
            score_breakdown['factors']['age']['details'] = f"Error: {str(e)}"

        # Religion Compatibility (10 points)
        try:
            candidate_religion = str(candidate_detail.get("religion", "")).lower()
            religion_pref = user_prefs.get("religion") or user_prefs.get("religions")
            user_religion_pref = self._parse_preferences(religion_pref)
            
            if not user_religion_pref or "any" in user_religion_pref or candidate_religion in user_religion_pref:
                score_breakdown['factors']['religion']['score'] = 10
                score_breakdown['factors']['religion']['details'] = "Matches your preferences"
            else:
                score_breakdown['factors']['religion']['score'] = 0
                score_breakdown['factors']['religion']['details'] = f"Doesn't match your preferred religions: {user_religion_pref}"
        except Exception as e:
            score_breakdown['factors']['religion']['details'] = f"Error: {str(e)}"

        # Education Compatibility (10 points)
        try:
            candidate_education = str(candidate_detail.get("education", "")).lower()
            education_pref = user_prefs.get("education_level") or user_prefs.get("education_levels")
            user_education_pref = self._parse_preferences(education_pref)
            
            if not user_education_pref or "any" in user_education_pref or candidate_education in user_education_pref:
                score_breakdown['factors']['education']['score'] = 10
                score_breakdown['factors']['education']['details'] = "Matches your preferences"
            else:
                score_breakdown['factors']['education']['score'] = 0
                score_breakdown['factors']['education']['details'] = f"Doesn't match your preferred education levels: {user_education_pref}"
        except Exception as e:
            score_breakdown['factors']['education']['details'] = f"Error: {str(e)}"

        # Profession Compatibility (5 points)
        try:
            candidate_profession = str(candidate_detail.get("profession", "")).lower()
            profession_pref = user_prefs.get("profession") or user_prefs.get("professions")
            user_profession_pref = self._parse_preferences(profession_pref)
            
            if not user_profession_pref or candidate_profession in user_profession_pref:
                score_breakdown['factors']['profession']['score'] = 5
                score_breakdown['factors']['profession']['details'] = "Matches your preferences"
            else:
                score_breakdown['factors']['profession']['score'] = 0
                score_breakdown['factors']['profession']['details'] = f"Doesn't match your preferred professions: {user_profession_pref}"
        except Exception as e:
            score_breakdown['factors']['profession']['details'] = f"Error: {str(e)}"

        # Hobbies Compatibility (10 points)
        try:
            user_hobbies = set(str(h).lower() for h in user_detail.get("hobbies", []))
            candidate_hobbies = set(str(h).lower() for h in candidate_detail.get("hobbies", []))
            
            if user_hobbies and candidate_hobbies:
                common = user_hobbies & candidate_hobbies
                match_percentage = len(common) / len(user_hobbies)
                score_breakdown['factors']['hobbies']['score'] = round(10 * match_percentage, 2)
                score_breakdown['factors']['hobbies']['details'] = {
                    'common_hobbies': list(common),
                    'missing_hobbies': list(user_hobbies - candidate_hobbies),
                    'match_percentage': f"{match_percentage*100:.1f}%"
                }
            else:
                score_breakdown['factors']['hobbies']['score'] = 0
                score_breakdown['factors']['hobbies']['details'] = "No hobbies data to compare"
        except Exception as e:
            score_breakdown['factors']['hobbies']['details'] = f"Error: {str(e)}"

        # Marital Status Compatibility (10 points)
        try:
            candidate_marital = str(candidate_detail.get("marital_status", "")).lower()
            marital_pref = user_prefs.get("marital_status") or user_prefs.get("marital_statuses")
            user_marital_pref = self._parse_preferences(marital_pref)
            
            if not user_marital_pref or "any" in user_marital_pref or candidate_marital in user_marital_pref:
                score_breakdown['factors']['marital_status']['score'] = 10
                score_breakdown['factors']['marital_status']['details'] = "Matches your preferences"
            else:
                score_breakdown['factors']['marital_status']['score'] = 0
                score_breakdown['factors']['marital_status']['details'] = f"Doesn't match your preferred marital statuses: {user_marital_pref}"
        except Exception as e:
            score_breakdown['factors']['marital_status']['details'] = f"Error: {str(e)}"

        # Distance Compatibility (10 points)
        try:
            long_distance_pref = str(user_prefs.get("long_distance", "")).lower()
            prefers_long_distance = long_distance_pref in ["yes", "true", "1"]
            
            if prefers_long_distance:
                score_breakdown['factors']['distance']['score'] = 10
                score_breakdown['factors']['distance']['details'] = "You accept long distance relationships"
            else:
                if distance_km <= 50:
                    score_breakdown['factors']['distance']['score'] = 10
                    score_breakdown['factors']['distance']['details'] = "Very close (≤50km)"
                elif distance_km <= 100:
                    score_breakdown['factors']['distance']['score'] = 8
                    score_breakdown['factors']['distance']['details'] = f"Close ({distance_km:.1f}km)"
                elif distance_km <= 250:
                    score_breakdown['factors']['distance']['score'] = 5
                    score_breakdown['factors']['distance']['details'] = f"Moderate distance ({distance_km:.1f}km)"
                elif distance_km <= 500:
                    score_breakdown['factors']['distance']['score'] = 3
                    score_breakdown['factors']['distance']['details'] = f"Far ({distance_km:.1f}km)"
                else:
                    score_breakdown['factors']['distance']['score'] = 0
                    score_breakdown['factors']['distance']['details'] = f"Too far ({distance_km:.1f}km)"
        except Exception as e:
            score_breakdown['factors']['distance']['details'] = f"Error: {str(e)}"

        # Personality Compatibility (10 points)
        try:
            candidate_personality = str(candidate_detail.get("personality", "")).lower()
            personality_pref = user_prefs.get("personality")
            user_personality_pref = self._parse_preferences(personality_pref)
            
            if not user_personality_pref or "any" in user_personality_pref or candidate_personality in user_personality_pref:
                score_breakdown['factors']['personality']['score'] = 10
                score_breakdown['factors']['personality']['details'] = "Matches your preferences"
            else:
                score_breakdown['factors']['personality']['score'] = 0
                score_breakdown['factors']['personality']['details'] = f"Doesn't match your preferred personalities: {user_personality_pref}"
        except Exception as e:
            score_breakdown['factors']['personality']['details'] = f"Error: {str(e)}"

        # Living Preference Compatibility (10 points)
        try:
            user_living_pref = self._parse_preferences(user_prefs.get("living_preference"))
            candidate_living_pref = self._parse_preferences(candidate_detail.get("living_preference"))
            
            if not user_living_pref or "any" in user_living_pref:
                score_breakdown['factors']['living_preference']['score'] = 10
                score_breakdown['factors']['living_preference']['details'] = "No specific preference"
            elif candidate_living_pref and any(p in user_living_pref for p in candidate_living_pref):
                score_breakdown['factors']['living_preference']['score'] = 10
                score_breakdown['factors']['living_preference']['details'] = "Compatible living preferences"
            else:
                score_breakdown['factors']['living_preference']['score'] = 0
                score_breakdown['factors']['living_preference']['details'] = f"Different living preferences: {user_living_pref} vs {candidate_living_pref}"
        except Exception as e:
            score_breakdown['factors']['living_preference']['details'] = f"Error: {str(e)}"

        # Family Type Compatibility (10 points)
        try:
            user_family_pref = self._parse_preferences(user_prefs.get("family_type"))
            candidate_family_pref = self._parse_preferences(candidate_detail.get("family_type"))
            
            if not user_family_pref or "any" in user_family_pref:
                score_breakdown['factors']['family_type']['score'] = 10
                score_breakdown['factors']['family_type']['details'] = "No specific preference"
            elif candidate_family_pref and any(p in user_family_pref for p in candidate_family_pref):
                score_breakdown['factors']['family_type']['score'] = 10
                score_breakdown['factors']['family_type']['details'] = "Compatible family types"
            else:
                score_breakdown['factors']['family_type']['score'] = 0
                score_breakdown['factors']['family_type']['details'] = f"Different family type preferences: {user_family_pref} vs {candidate_family_pref}"
        except Exception as e:
            score_breakdown['factors']['family_type']['details'] = f"Error: {str(e)}"

        # Family Values Compatibility (10 points)
        try:
            user_values_pref = self._parse_preferences(user_prefs.get("family_values"))
            candidate_values_pref = self._parse_preferences(candidate_detail.get("family_values"))
            
            if not user_values_pref or "any" in user_values_pref:
                score_breakdown['factors']['family_values']['score'] = 10
                score_breakdown['factors']['family_values']['details'] = "No specific preference"
            elif candidate_values_pref and any(p in user_values_pref for p in candidate_values_pref):
                score_breakdown['factors']['family_values']['score'] = 10
                score_breakdown['factors']['family_values']['details'] = "Compatible family values"
            else:
                score_breakdown['factors']['family_values']['score'] = 0
                score_breakdown['factors']['family_values']['details'] = f"Different family values: {user_values_pref} vs {candidate_values_pref}"
        except Exception as e:
            score_breakdown['factors']['family_values']['details'] = f"Error: {str(e)}"

        # Pet Preference Compatibility (5 points)
        try:
            user_pet_pref = self._parse_preferences(user_prefs.get("pet_preference"))
            candidate_pet_pref = self._parse_preferences(candidate_detail.get("pet_preference"))
            
            if not user_pet_pref or "any" in user_pet_pref:
                score_breakdown['factors']['pet_preference']['score'] = 5
                score_breakdown['factors']['pet_preference']['details'] = "No specific preference"
            elif candidate_pet_pref and any(p in user_pet_pref for p in candidate_pet_pref):
                score_breakdown['factors']['pet_preference']['score'] = 5
                score_breakdown['factors']['pet_preference']['details'] = "Compatible pet preferences"
            else:
                score_breakdown['factors']['pet_preference']['score'] = 0
                score_breakdown['factors']['pet_preference']['details'] = f"Different pet preferences: {user_pet_pref} vs {candidate_pet_pref}"
        except Exception as e:
            score_breakdown['factors']['pet_preference']['details'] = f"Error: {str(e)}"

        # Calculate total score - SIMPLIFIED VERSION
        total_score = 0
        total_possible = 0
        
        for factor, data in score_breakdown['factors'].items():
            total_score += data['score']
            total_possible += data['weight']
        
        if total_possible > 0:
            score_breakdown['total_score'] = min(100, max(0, round((total_score / total_possible) * 100, 2)))
        else:
            score_breakdown['total_score'] = 0
        
        return score_breakdown

    def _get_document(self, collection, user_id):
        """Helper to get document by user_id"""
        return collection.find_one({"user_id": user_id}) or collection.find_one({"user_id": str(user_id)})

    def _get_interests_list(self, interests_doc, details_doc):
        """Get combined interests list from documents"""
        interests = []
        def extend_clean(data):
            if isinstance(data, list):
                interests.extend([i.strip() for i in data if i])
            elif isinstance(data, str):
                interests.append(data.strip())

        if interests_doc:
            extend_clean(interests_doc.get("interests"))
            extend_clean(interests_doc.get("hobbies"))
            extend_clean(interests_doc.get("personality"))

            looking_for = interests_doc.get("looking_for", {})
            if isinstance(looking_for, dict):
                extend_clean(looking_for.get("interests"))
                extend_clean(looking_for.get("hobbies"))
                extend_clean(looking_for.get("personality"))

        if details_doc:
            extend_clean(details_doc.get("interests"))
            extend_clean(details_doc.get("hobbies"))
            extend_clean(details_doc.get("personality"))

        return list(set(filter(None, interests)))

    def _haversine(self, lat1, lon1, lat2, lon2):
        """Calculate distance between two points on Earth (in km)"""
        R = 6371.0
        dlat = radians(lat2 - lat1)
        dlon = radians(lon2 - lon1)
        a = sin(dlat / 2) ** 2 + cos(radians(lat1)) * cos(radians(lat2)) * sin(dlon / 2) ** 2
        c = 2 * atan2(sqrt(a), sqrt(1 - a))
        return R * c

    def _get_location(self, user_detail):
        """Extract location coordinates from user detail"""
        if not user_detail:
            return None
        if "location_coordinates" in user_detail:
            coords = user_detail["location_coordinates"]
            if isinstance(coords, dict):
                try:
                    lat = float(coords.get("lat", 0))
                    lng = float(coords.get("lng", 0))
                    if lat != 0 and lng != 0:
                        return {"lat": lat, "lng": lng}
                except (ValueError, TypeError):
                    pass
        try:
            lat = user_detail.get("latitude")
            lng = user_detail.get("longitude")
            if lat is not None and lng is not None:
                return {
                    "lat": float(lat),
                    "lng": float(lng)
                }
        except (ValueError, TypeError):
            pass
        return None

    def _build_photo_url(self, request, raw_photo):
        """Build full photo URL from request"""
        base_url = request.host_url.rstrip('/')
        if raw_photo:
            if raw_photo.startswith("/uploads/"):
                return f"{base_url}{raw_photo}"
            return raw_photo
        return f"{base_url}/default-profile.jpg"

    def _process_candidate(self, request, candidate, partner_gender_pref, liked_emails, liked_by_emails, user_detail, user_interests_list, user_location):
        """Enhanced to include score breakdown"""
        email = candidate.get("email")
        if email in liked_emails or email in liked_by_emails:
            return None

        detail = self._get_document(self.details, candidate["_id"])
        if not detail:
            return None

        candidate_interests = self._get_document(self.interests, candidate["_id"])
        if candidate_interests and isinstance(candidate_interests.get("looking_for"), dict):
            looking_for = candidate_interests["looking_for"]
            detail.update({
                "living_preference": looking_for.get("living_preference"),
                "family_type": looking_for.get("family_type"),
                "family_values": looking_for.get("family_values"),
                "pet_preference": looking_for.get("pet_preference")
            })
        candidate_location = self._get_location(detail)

        distance = None
        if user_location and candidate_location:
            distance = self._haversine(
                user_location["lat"], user_location["lng"],
                candidate_location["lat"], candidate_location["lng"]
            )

        compatibility = self._calculate_compatibility(
            user_detail,
            self._get_document(self.interests, user_detail.get("user_id") or user_detail.get("_id")),
            detail,
            distance or 0
        )

        if not compatibility['filter_passed']:
            return None

        return {
            "id": str(candidate["_id"]),
            "name": candidate.get("name"),
            "email": email,
            "age": detail.get("age"),
            "gender": detail.get("gender"),
            "religion": detail.get("religion"),
            "caste": detail.get("caste"),
            "marital_status": detail.get("marital_status"),
            "location": detail.get("location"),
            "profession": detail.get("profession"),
            "living_preference": detail.get("living_preference"),
            "family_type": detail.get("family_type"),
            "family_values": detail.get("family_values"),
            "pet_preference": detail.get("pet_preference"),
            "education": detail.get("education"),
            "bio": detail.get("caption", "No bio available."),
            "personality": detail.get("personality", []),
            "hobbies": detail.get("hobbies", []),
            "images": [self._build_photo_url(request, candidate.get("photo"))],
            "is_match": email in liked_by_emails,
            "distance_km": round(distance, 2) if distance is not None else None,
            "compatibility_score": compatibility['total_score'],
            "score_breakdown": {
                'total_score': compatibility['total_score'],
                'factors': compatibility['factors'],
                'filter_passed': compatibility['filter_passed'],
                'rejection_reason': compatibility['rejection_reason']
            }
        }

    def get_profiles(self, request, current_email):
        """Get potential matches for current user"""
        user = self.users.find_one({"email": current_email})
        if not user:
            return {"profiles": []}

        user_detail = self._get_document(self.details, user["_id"])
        if not user_detail:
            return {"profiles": []}

        user_interests = self._get_document(self.interests, user["_id"])
        user_location = self._get_location(user_detail)
        liked_emails, liked_by_emails = self._get_swipe_data(current_email)
        partner_gender_pref = self._get_gender_preference(user_interests or {})

        profiles = []
        for candidate in self.users.find({"email": {"$ne": current_email}}):
            profile = self._process_candidate(
                request, candidate, partner_gender_pref,
                liked_emails, liked_by_emails,
                user_detail, user_interests, user_location
            )
            if profile:
                profiles.append(profile)

        # Sort by compatibility score descending
        profiles.sort(key=lambda x: -x["compatibility_score"])

        return {
            "profiles": profiles,
            "logged_in_user": self._build_user_profile(request, user, user_detail, user_interests)
        }

    def _get_gender_preference(self, user_interests):
        """Extract gender preference from user interests"""
        if not user_interests:
            return "any"
        
        if "looking_for" in user_interests and isinstance(user_interests["looking_for"], dict):
            if "gender" in user_interests["looking_for"]:
                pref = user_interests["looking_for"]["gender"]
                if pref:
                    return str(pref).strip().lower()
        
        if "gender_preference" in user_interests:
            pref = user_interests["gender_preference"]
            if pref:
                return str(pref).strip().lower()
        
        return "any"

    def _get_swipe_data(self, current_email):
        """Get swipes involving current user"""
        swiped_by_user = {s["target"] for s in self.swipes.find({"swiper": current_email})}
        swiped_on_user = {s["swiper"] for s in self.swipes.find({"target": current_email})}
        return swiped_by_user, swiped_on_user

    def _build_user_profile(self, request, user, user_detail, interests):
        """Build profile object for response"""
        looking_for = {}
        if user_detail:
            raw_interests = self._get_document(self.interests, user["_id"])
            if raw_interests and isinstance(raw_interests.get("looking_for"), dict):
                looking_for = raw_interests["looking_for"]

        return {
            "name": user.get("name"),
            "email": user.get("email"),
            "gender": user_detail.get("gender") if user_detail else None,
            "age": user_detail.get("age") if user_detail else None,
            "location": user_detail.get("location") if user_detail else None,
            "religion": user_detail.get("religion") if user_detail else None,
            "caste": user_detail.get("caste") if user_detail else None,
            "marital_status": user_detail.get("marital_status") if user_detail else None,
            "education": user_detail.get("education") if user_detail else None,
            "profession": user_detail.get("profession") if user_detail else None,
            "bio": user_detail.get("caption", "No bio available.") if user_detail else None,
            "hobbies": user_detail.get("hobbies", []) if user_detail else [],
            "looking_for": looking_for,
            "images": [self._build_photo_url(request, user.get("photo"))] if user.get("photo") else [self._build_photo_url(request, None)]
        }







        ````````````````final````````````````````````
        from math import radians, sin, cos, sqrt, atan2

class MatchAlgorithm:
    def __init__(self, db):
        self.users = db["users"]
        self.details = db["user_details"]
        self.interests = db["user_interests"]
        self.swipes = db["swipes"]

    def _cosine_similarity(self, vec1, vec2):
        dot_product = sum(a*b for a,b in zip(vec1, vec2))
        magnitude1 = sqrt(sum(a**2 for a in vec1))
        magnitude2 = sqrt(sum(b**2 for b in vec2))
        
        if magnitude1 == 0 or magnitude2 == 0:
            return 0
        return dot_product / (magnitude1 * magnitude2)

    def _text_to_vector(self, text):
        words = text.lower().split()
        word_counts = {}
        for word in words:
            word_counts[word] = word_counts.get(word, 0) + 1
        return word_counts

    def _vectorize_features(self, user_data, candidate_data, user_interests, candidate_interests):
        user_family_type = ""
        if user_interests and isinstance(user_interests.get("looking_for"), dict):
            user_family_type = str(user_interests["looking_for"].get("family_type", ""))
        elif user_data:
            user_family_type = str(user_data.get("family_type", ""))

        candidate_family_type = ""
        if candidate_interests and isinstance(candidate_interests.get("looking_for"), dict):
            candidate_family_type = str(candidate_interests["looking_for"].get("family_type", ""))
        elif candidate_data:
            candidate_family_type = str(candidate_data.get("family_type", ""))
        
        user_family_value = ""
        if user_interests and isinstance(user_interests.get("looking_for"), dict):
            user_family_value = str(user_interests["looking_for"].get("family_value", ""))
        elif user_data:
            user_family_value = str(user_data.get("family_value", ""))

        candidate_family_value = ""
        if candidate_interests and isinstance(candidate_interests.get("looking_for"), dict):
            candidate_family_value = str(candidate_interests["looking_for"].get("family_value", ""))
        elif candidate_data:
            candidate_family_value = str(candidate_data.get("family_value", ""))

        features = {
            'religion': str(user_data.get("religion", "")) if user_data else "",
            'education': str(user_data.get("education", "")) if user_data else "",
            'profession': str(user_data.get("profession", "")) if user_data else "",
            'family_type': user_family_type,
            'family_value': user_family_value,
            'hobbies': " ".join(user_data.get("hobbies", [])) if user_data else "",
            'personality': " ".join(user_data.get("personality", [])) if user_data else ""
        }

        candidate_features = {
            'religion': str(candidate_data.get("religion", "")) if candidate_data else "",
            'education': str(candidate_data.get("education", "")) if candidate_data else "",
            'profession': str(candidate_data.get("profession", "")) if candidate_data else "",
            'family_type': candidate_family_type,
            'family_value': candidate_family_value,
            'hobbies': " ".join(candidate_data.get("hobbies", [])) if candidate_data else "",
            'personality': " ".join(candidate_data.get("personality", [])) if candidate_data else ""
        }

        user_text = " ".join(features.values())
        candidate_text = " ".join(candidate_features.values())

        user_vec = self._text_to_vector(user_text)
        candidate_vec = self._text_to_vector(candidate_text)

        all_words = set(user_vec.keys()).union(set(candidate_vec.keys()))
        vec1 = [user_vec.get(word, 0) for word in all_words]
        vec2 = [candidate_vec.get(word, 0) for word in all_words]

        return vec1, vec2, features

    def _parse_preferences(self, preference_value):
        if not preference_value:
            return set()
        
        if isinstance(preference_value, list):
            return {str(item).strip().lower() for item in preference_value}
        
        if isinstance(preference_value, str):
            if ',' in preference_value:
                return {item.strip().lower() for item in preference_value.split(',')}
            return {preference_value.strip().lower()}
        
        return set()

    def _apply_rule_based_filtering(self, user_prefs, candidate_data,interests_data):
        preferred_genders = self._parse_preferences(user_prefs.get("gender", "any"))
        candidate_gender = str(candidate_data.get("gender", "")).lower()
        
        if "any" not in preferred_genders and candidate_gender not in preferred_genders:
            return False, "Gender preference mismatch"

        user_caste_prefs = self._parse_preferences(user_prefs.get("caste", "any"))
        candidate_caste = str(candidate_data.get("caste", "")).lower()
        
        if "any" not in user_caste_prefs and candidate_caste:
            if candidate_caste not in user_caste_prefs:
                return False, f"Caste not in preferred: {user_caste_prefs}"

        return True, "Passed all filters"

    def _calculate_compatibility(self, user_detail, user_interests, candidate_detail, candidate_interests, distance_km):

        score_breakdown = {
            'total_score': 0,
            'content_similarity': {'score': 0, 'matched_features': []},
            'location': {'score': 0, 'distance_km': distance_km},
            'age': {'score': 0, 'user_age': user_detail.get("age"), 'candidate_age': candidate_detail.get("age")},
            'family_value': {'score': 0,
                 'user_family_value': user_interests.get("looking_for", {}).get("family_value"),
                 'candidate_family_value': candidate_interests.get("looking_for", {}).get("family_value")},
            'family_type': {'score': 0,
                'user_family_type': user_interests.get("looking_for", {}).get("family_type"),
                'candidate_family_type': candidate_interests.get("looking_for", {}).get("family_type")},

            'interests': {'score': 0, 'common_hobbies': [], 'user_hobbies': [], 'candidate_hobbies': []},
            'filter_passed': True,
            'rejection_reason': None
        }

        user_prefs = user_interests.get("looking_for", {})
        passed, reason = self._apply_rule_based_filtering(user_prefs, candidate_detail, candidate_interests)
        if not passed:
            score_breakdown['filter_passed'] = False
            score_breakdown['rejection_reason'] = reason
            return score_breakdown

        vec1, vec2, features = self._vectorize_features(user_detail, candidate_detail, user_interests, candidate_interests)
        content_score = self._cosine_similarity(vec1, vec2) * 70
        score_breakdown['content_similarity']['score'] = content_score
        score_breakdown['content_similarity']['matched_features'] = [f"{k}: {v}" for k, v in features.items() if v]

        location_score = 0
        if distance_km <= 50:
            location_score = 10
        elif distance_km <= 1000:
            location_score = 10 * (1 - (distance_km - 50) / 950)
        score_breakdown['location']['score'] = location_score

        age_score = 0
        try:
            candidate_age = candidate_detail.get("age")
            age_pref = user_prefs.get("age_group", "18-99")
            min_age, max_age = map(int, age_pref.split('-')) if '-' in age_pref else (18, 99)

            if min_age <= candidate_age <= max_age:
                age_score = 10
                score_breakdown['age']['match'] = f"Within preferred range ({min_age}-{max_age})"
            else:
                score_breakdown['age']['match'] = f"Outside preferred range ({min_age}-{max_age})"
        except Exception as e:
            score_breakdown['age']['error'] = str(e)
        score_breakdown['age']['score'] = age_score

        interest_score = 0
        user_hobbies = set(str(h).lower() for h in user_detail.get("hobbies", []))
        candidate_hobbies = set(str(h).lower() for h in candidate_detail.get("hobbies", []))
        score_breakdown['interests']['user_hobbies'] = list(user_hobbies)
        score_breakdown['interests']['candidate_hobbies'] = list(candidate_hobbies)

        if user_hobbies and candidate_hobbies:
            common = user_hobbies & candidate_hobbies
            interest_score = 10 * len(common) / len(user_hobbies)
            score_breakdown['interests']['common_hobbies'] = list(common)
            score_breakdown['interests']['match_percentage'] = f"{len(common)/len(user_hobbies)*100:.1f}%"

        score_breakdown['interests']['score'] = interest_score

        total_score = content_score + location_score + age_score + interest_score
        score_breakdown['total_score'] = round(min(100, max(0, total_score)))

        return score_breakdown


    def _get_document(self, collection, user_id):
        return collection.find_one({"user_id": user_id}) or collection.find_one({"user_id": str(user_id)})

    def _get_interests_list(self, interests_doc, details_doc):
        interests = []
        def extend_clean(data):
            if isinstance(data, list):
                interests.extend([i.strip() for i in data if i])
            elif isinstance(data, str):
                interests.append(data.strip())

        if interests_doc:
            extend_clean(interests_doc.get("interests"))
            extend_clean(interests_doc.get("hobbies"))
            extend_clean(interests_doc.get("personality"))

            looking_for = interests_doc.get("looking_for", {})
            if isinstance(looking_for, dict):
                extend_clean(looking_for.get("interests"))
                extend_clean(looking_for.get("hobbies"))
                extend_clean(looking_for.get("personality"))

        if details_doc:
            extend_clean(details_doc.get("interests"))
            extend_clean(details_doc.get("hobbies"))
            extend_clean(details_doc.get("personality"))

        return list(set(filter(None, interests)))

    def _haversine(self, lat1, lon1, lat2, lon2):
        R = 6371.0
        dlat = radians(lat2 - lat1)
        dlon = radians(lon2 - lon1)
        a = sin(dlat / 2) ** 2 + cos(radians(lat1)) * cos(radians(lat2)) * sin(dlon / 2) ** 2
        c = 2 * atan2(sqrt(a), sqrt(1 - a))
        return R * c

    def _get_location(self, user_detail):
        if not user_detail:
            return None
        if "location_coordinates" in user_detail:
            coords = user_detail["location_coordinates"]
            if isinstance(coords, dict):
                try:
                    lat = float(coords.get("lat", 0))
                    lng = float(coords.get("lng", 0))
                    if lat != 0 and lng != 0:
                        return {"lat": lat, "lng": lng}
                except (ValueError, TypeError):
                    pass
        try:
            lat = user_detail.get("latitude")
            lng = user_detail.get("longitude")
            if lat is not None and lng is not None:
                return {
                    "lat": float(lat),
                    "lng": float(lng)
                }
        except (ValueError, TypeError):
            pass
        return None

    def _build_photo_url(self, request, raw_photo):
        base_url = request.host_url.rstrip('/')
        if raw_photo:
            if raw_photo.startswith("/uploads/"):
                return f"{base_url}{raw_photo}"
            return raw_photo
        return f"{base_url}/default-profile.jpg"

    def _process_candidate(self, request, candidate, partner_gender_pref, liked_emails, liked_by_emails, user_detail, user_interests_list, user_location):
        email = candidate.get("email")
        if email in liked_emails or email in liked_by_emails:
            return None

        detail = self._get_document(self.details, candidate["_id"])
        if not detail:
            return None

        candidate_interests = self._get_document(self.interests, candidate["_id"])
        candidate_location = self._get_location(detail)

        distance = None
        if user_location and candidate_location:
            distance = self._haversine(
                user_location["lat"], user_location["lng"],
                candidate_location["lat"], candidate_location["lng"]
            )

        compatibility = self._calculate_compatibility(
        user_detail,
        self._get_document(self.interests, user_detail.get("user_id") or user_detail.get("_id")),
        detail,
        candidate_interests,
        distance or 0
    )


        if not compatibility['filter_passed']:
            return None

        return {
            "id": str(candidate["_id"]),
            "name": candidate.get("name"),
            "email": email,
            "age": detail.get("age"),
            "gender": detail.get("gender"),
            "religion": detail.get("religion"),
            "caste": detail.get("caste"),
            "marital_status": detail.get("marital_status"),
            "location": detail.get("location"),
            "profession": detail.get("profession"),
            # "family_type": detail.get("family_type"),
            # "family_value": detail.get("family_value"),
            "education": detail.get("education"),
            "bio": detail.get("caption", "No bio available."),
            "personality": detail.get("personality", []),
            "hobbies": detail.get("hobbies", []),
            "images": [self._build_photo_url(request, candidate.get("photo"))],
            "is_match": email in liked_by_emails,
            "distance_km": round(distance, 2) if distance is not None else None,
            "compatibility_score": compatibility['total_score'],
            "score_breakdown": {  # Detailed matching reasons
                'content_similarityyy': {
                    'score': f"{(compatibility['content_similarity']['score']):.1f}/70",
                    'matched_features': compatibility['content_similarity']['matched_features']
                },
               'location': {
                'score': f"{round(compatibility['location']['score'])}/10",  
                'distance': f"{distance:.1f} km" if distance else "Unknown"
                },
                'age': {
                    'score': f"{round(compatibility['age']['score'])}/10",  
                    'details': compatibility['age'].get('match', 'Not specified')
                },
                'interests': {
                    'score': f"{round(compatibility['interests']['score'])}/10", 
                    'common_hobbies': compatibility['interests']['common_hobbies'],
                    'match_percentage': compatibility['interests'].get('match_percentage', '0%')
                },
                'family_value': {
                    'score': f"{round(compatibility['family_value']['score'])}/10",  
                    'user_value': compatibility['family_value']['user_family_value'],
                    'candidate_value': compatibility['family_value']['candidate_family_value']
                },
                'family_type': {
                    'score': f"{round(compatibility['family_type']['score'])}/10",  
                    'user_type': compatibility['family_type']['user_family_type'],
                    'candidate_type': compatibility['family_type']['candidate_family_type']
                }
            }
        }

    def get_profiles(self, request, current_email):
        user = self.users.find_one({"email": current_email})
        if not user:
            return {"profiles": []}

        user_detail = self._get_document(self.details, user["_id"])
        if not user_detail:
            return {"profiles": []}

        user_interests = self._get_document(self.interests, user["_id"])
        user_location = self._get_location(user_detail)
        liked_emails, liked_by_emails = self._get_swipe_data(current_email)
        partner_gender_pref = self._get_gender_preference(user_interests or {})

        profiles = []
        for candidate in self.users.find({"email": {"$ne": current_email}}):
            profile = self._process_candidate(
                request, candidate, partner_gender_pref,
                liked_emails, liked_by_emails,
                user_detail, user_interests, user_location
            )
            if profile:
                profiles.append(profile)

        profiles.sort(key=lambda x: -x["compatibility_score"])

        return {
            "profiles": profiles,
            "logged_in_user": self._build_user_profile(request, user, user_detail, user_interests)
        }

    def _get_gender_preference(self, user_interests):
        if not user_interests:
            return "any"
        
        if "looking_for" in user_interests and isinstance(user_interests["looking_for"], dict):
            if "gender" in user_interests["looking_for"]:
                pref = user_interests["looking_for"]["gender"]
                if pref:
                    return str(pref).strip().lower()
        
        if "gender_preference" in user_interests:
            pref = user_interests["gender_preference"]
            if pref:
                return str(pref).strip().lower()
        
        return "any"

    def _get_swipe_data(self, current_email):
        swiped_by_user = {s["target"] for s in self.swipes.find({"swiper": current_email})}
        swiped_on_user = {s["swiper"] for s in self.swipes.find({"target": current_email})}
        return swiped_by_user, swiped_on_user

    def _build_user_profile(self, request, user, user_detail, interests):
        looking_for = {}
        if user_detail:
            raw_interests = self._get_document(self.interests, user["_id"])
            if raw_interests and isinstance(raw_interests.get("looking_for"), dict):
                looking_for = raw_interests["looking_for"]

        return {
            "name": user.get("name"),
            "email": user.get("email"),
            "gender": user_detail.get("gender") if user_detail else None,
            "age": user_detail.get("age") if user_detail else None,
            "location": user_detail.get("location") if user_detail else None,
            "religion": user_detail.get("religion") if user_detail else None,
            "caste": user_detail.get("caste") if user_detail else None,
            "marital_status": user_detail.get("marital_status") if user_detail else None,
            # "family_type": user_detail.get("family_type") if user_detail else None,
            # "family_value": user_detail.get("family_value") if user_detail else None,
            "education": user_detail.get("education") if user_detail else None,
            "profession": user_detail.get("profession") if user_detail else None,
            "bio": user_detail.get("caption", "No bio available.") if user_detail else None,
            "personality": user_detail.get("personality", []) if user_detail else [],
            "hobbies": user_detail.get("hobbies", []) if user_detail else [],
            "looking_for": looking_for,
              "images": [self._build_photo_url(request, user.get("photo"))] if user.get("photo") else [self._build_photo_url(request, None)]
        }
        \





        from bson.objectid import ObjectId
from datetime import datetime

from math import radians, sin, cos, sqrt, atan2

class   MatchService:
    def __init__(self, db):
        self.users = db["users"]
        self.details = db["user_details"]
        self.swipes = db["swipes"]
        self.notifications = db["notifications"]
        self.matches = db["matches"]
    def _cosine_similarity(self, vec1, vec2):
        dot_product = sum(a*b for a,b in zip(vec1, vec2))
        magnitude1 = sqrt(sum(a**2 for a in vec1))
        magnitude2 = sqrt(sum(b**2 for b in vec2))
        
        if magnitude1 == 0 or magnitude2 == 0:
            return 0
        return dot_product / (magnitude1 * magnitude2)

    def _text_to_vector(self, text):
        words = text.lower().split()
        word_counts = {}
        for word in words:
            word_counts[word] = word_counts.get(word, 0) + 1
        return word_counts

    def build_photo_url(self, request, raw_photo):
        base_url = request.host_url.rstrip('/')
        if raw_photo:
            if raw_photo.startswith("/uploads/"):
                return f"{base_url}{raw_photo}"
            return raw_photo
        return f"{base_url}/default-profile.jpg"

    def get_sent_requests(self, email, request):
        liked = self.swipes.find({"swiper": email, "liked": True})
        liked_emails = [s["target"] for s in liked]

        reverse_likes = self.swipes.find({"target": email, "liked": True})
        reverse_emails = [s["swiper"] for s in reverse_likes]

        pending_requests = set(liked_emails) - set(reverse_emails)

        profiles = []
        for user in self.users.find({"email": {"$in": list(pending_requests)}}):
            detail = self.details.find_one({"user_id": user["_id"]})
            if not detail:
                continue
            photo_url = self.build_photo_url(request, user.get("photo"))
            profiles.append({
                "id": str(user["_id"]),
                "name": user.get("name"),
                "email": user.get("email"),
                "age": detail.get("age"),
                "location": detail.get("location"),
                "photos": [photo_url],
            })

        return profiles

    def get_profiles(self, request, current_email):
        liked_emails = {s["target"] for s in self.swipes.find({"swiper": current_email, "liked": True})}
        liked_by_emails = {s["swiper"] for s in self.swipes.find({"target": current_email, "liked": True})}

        profiles = []
        for user in self.users.find():
            email = user.get("email")
            if email == current_email or email in liked_emails:
                continue

            detail = self.details.find_one({"user_id": user["_id"]})
            if not detail:
                continue

            photo_url = self.build_photo_url(request, user.get("photo"))
            profiles.append({
                "id": str(user["_id"]),  
                "name": user.get("name"),
                "email": email,
                "age": detail.get("age"),
                "location": detail.get("location"),
                "profession": detail.get("profession"),
                "education": detail.get("education"),
                "bio": detail.get("caption", "No bio available."),
                "hobbies": detail.get("hobbies", []),
                "images": [photo_url],
                "is_match": email in liked_by_emails
            })
        return profiles


    def swipe(self, swiper, target, liked):
        self.swipes.update_one(
            {"swiper": swiper, "target": target},
            {"$set": {"liked": liked, "timestamp": datetime.utcnow()}},
            upsert=True
        )

        self.notifications.delete_many({"to": swiper, "from": target, "type": "request"})

        if liked:
            reverse = self.swipes.find_one({"swiper": target, "target": swiper, "liked": True})
            match = self.matches.find_one({"users": {"$all": [swiper, target]}})

            if reverse and not match:
                match_doc = {
                    "users": sorted([swiper, target]),
                    "timestamp": datetime.utcnow()
                }
                match_id = self.matches.insert_one(match_doc).inserted_id

                for user1, user2 in [(swiper, target), (target, swiper)]:
                    self.notifications.insert_one({
                        "to": user1,
                        "from": user2,
                        "type": "match",
                        "message": f"You matched with {user2}!",
                        "read": False,
                        "timestamp": datetime.utcnow()
                    })

                return {"match": True, "match_id": str(match_id)}

            else:
                self.notifications.insert_one({
                    "to": target,
                    "from": swiper,
                    "type": "request",
                    "message": f"{swiper} liked your profile!",
                    "read": False,
                    "timestamp": datetime.utcnow()
                })

        else:
            match = self.matches.find_one({"users": {"$all": [swiper, target]}})
            if match:
                self.matches.delete_one({"_id": match["_id"]})
                self.notifications.delete_many({
                    "type": "match",
                    "$or": [
                        {"to": swiper, "from": target},
                        {"to": target, "from": swiper}
                    ]
                })

        return {"match": False}

    def get_notifications(self, email, request):
        notes = list(self.notifications.find({
            "to": email,
            "type": {"$in": ["request", "match"]}
        }).sort("timestamp", -1).limit(50))

        for n in notes:
            n["_id"] = str(n["_id"])
            n["timestamp"] = n["timestamp"].isoformat()
            sender = self.users.find_one({"email": n["from"]})
            if sender:
                n["sender_name"] = sender.get("name")
                n["sender_id"] = str(sender["_id"])  
                n["sender_image"] = self.build_photo_url(request, sender.get("photo"))

                detail = self.details.find_one({"user_id": sender["_id"]})
                if detail:
                    n["sender_age"] = detail.get("age")
                    n["sender_location"] = detail.get("location")
                    n["sender_profession"] = detail.get("profession")
                    n["sender_education"] = detail.get("education")
                    n["sender_hobbies"] = detail.get("hobbies", [])
                    n["sender_caption"] = detail.get("caption", "")
                    n["compatibility_score"] = detail.get("compatibility_score", "0")
        return notes

    def mark_read(self, notification_id):
        return self.notifications.update_one(
            {"_id": ObjectId(notification_id)},
            {"$set": {"read": True}}
        )

    def ignore(self, notification_id):
        notification = self.notifications.find_one({"_id": ObjectId(notification_id)})
        if not notification:
            return False

        self.notifications.delete_one({"_id": ObjectId(notification_id)})

        if notification["type"] == "request":
            self.swipes.update_one(
                {"swiper": notification["from"], "target": notification["to"]},
                {"$set": {"liked": False, "timestamp": datetime.utcnow()}},
                upsert=True
            )
        return True

    def get_mutual_matches(self, email, request):
        matched_docs = self.matches.find({"users": email})
        matched_emails = [u for m in matched_docs for u in m["users"] if u != email]

        profiles = []
        for user in self.users.find({"email": {"$in": matched_emails}}):
            detail = self.details.find_one({"user_id": user["_id"]})
            if not detail:
                continue
            photo_url = self.build_photo_url(request, user.get("photo"))
            profiles.append({
                "name": user.get("name"),
                "email": user.get("email"),
                "images": [photo_url],
                # "location": detail.get("location"),
            })
        return profiles

    def cancel_sent_request(self, swiper_email, target_email):
        swipe_result = self.swipes.delete_one({
            "swiper": swiper_email,
            "target": target_email,
            "liked": True
        })

        self.notifications.delete_many({
            "from": swiper_email,
            "to": target_email,
            "type": "request"
        })

        return swipe_result.deleted_count > 0
    


    def get_similar_to_liked_users(self, email, request):
        current_user = self.users.find_one({"email": email})
        if not current_user:
            return []
        
        current_detail = self.details.find_one({"user_id": current_user["_id"]})
        if not current_detail:
            return []

        swiped_users = list(self.swipes.find({"swiper": email, "liked": True}))
        swiped_emails = [entry["target"] for entry in swiped_users]

        if not swiped_emails:
            return []

        liked_users = list(self.users.find({"email": {"$in": swiped_emails}}))
        liked_user_ids = [user["_id"] for user in liked_users]
        liked_details = list(self.details.find({"user_id": {"$in": liked_user_ids}}))

        if not liked_details:
            return []

        def get_most_common(vectors, key):
            values = [v.get(key, "").lower() for v in vectors if v.get(key)]
            if not values:
                return None
            return max(set(values), key=values.count)

        preferred_gender = get_most_common(liked_details, "gender")
        preferred_caste = get_most_common(liked_details, "caste")

        def create_profile_text(detail):
            return " ".join([
                detail.get("gender", "").lower(),
                detail.get("caste", "").lower(),
                detail.get("religion", "").lower(),
                " ".join(h.lower() for h in detail.get("hobbies", [])),
                str(detail.get("age", 0)),
                detail.get("profession", "").lower(),
                detail.get("education", "").lower()
            ])

        liked_text = " ".join(create_profile_text(d) for d in liked_details)

        candidate_users = list(self.users.find({
            "email": {"$nin": swiped_emails + [email]}
        }))

        candidates = []
        for user in candidate_users:
            detail = self.details.find_one({"user_id": user["_id"]})
            if not detail:
                continue

            # Rule-based filtering
            candidate_gender = detail.get("gender", "").lower()
            candidate_caste = detail.get("caste", "").lower()

            if preferred_gender and candidate_gender != preferred_gender:
                continue

            if preferred_caste and candidate_caste != preferred_caste:
                continue

            candidate_text = create_profile_text(detail)

            liked_vec = self._text_to_vector(liked_text)
            candidate_vec = self._text_to_vector(candidate_text)
            
            all_words = set(liked_vec.keys()).union(set(candidate_vec.keys()))
            vec1 = [liked_vec.get(word, 0) for word in all_words]
            vec2 = [candidate_vec.get(word, 0) for word in all_words]
            
            similarity = self._cosine_similarity(vec1, vec2)

            if similarity > 0.3:
                photo = user.get("photo")
                candidates.append({
                    "id": str(user["_id"]),
                    "name": user.get("name", "Unknown"),
                    "email": user.get("email", ""),
                    "images": [self.build_photo_url(request, photo)] if photo else [],
                    "location": detail.get("location", ""),
                    "age": detail.get("age", ""),
                    "profession": detail.get("profession", ""),
                    "education": detail.get("education", ""),
                    "similarity_score": round(similarity, 3)
                })

        return sorted(candidates, key=lambda x: x["similarity_score"], reverse=True)[:5]